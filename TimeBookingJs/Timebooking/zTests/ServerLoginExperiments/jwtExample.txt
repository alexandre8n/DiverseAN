steps:
1) initialize project:
/my-app = ServerLoginExperiments
  ├─ node_modules/
  ├─ package.json
  ├─ .env
  └─ server.js

do it like this:

npm init -y
npm i express cors jsonwebtoken bcrypt dotenv
Создай файл .env (не коммить в репо):

PORT=3000
JWT_SECRET=super_long_random_access_secret
JWT_REFRESH_SECRET=super_long_random_refresh_secret


////////////////////////////////////////
Server part code:
require("dotenv").config();
const express = require("express");
const cors = require("cors");
const jwt = require("jsonwebtoken");
const bcrypt = require("bcrypt");

const app = express();
app.use(cors());
app.use(express.json());

const PORT = process.env.PORT || 3000;
const JWT_SECRET = process.env.JWT_SECRET;
const JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET;

// ⚠️ Демонстрационная «БД»
const users = [
  // пароль "xxx" захэширован (пример: bcrypt.hashSync("xxx", 10))
  { id: 1, username: "user1", passwordHash: bcrypt.hashSync("xxx", 10), role: "user" },
];

// ⚠️ В проде храните refresh-токены в БД (или вообще не храните и делайте ротацию по jti).
const refreshStore = new Set();

/** Вспомогательные функции */
function signAccessToken(payload) {
  // Короткая жизнь access-токена — хорошая практика (10–30 минут)
  return jwt.sign(payload, JWT_SECRET, { expiresIn: "15m" });
}
function signRefreshToken(payload) {
  // Refresh живёт дольше (дни/недели). На проде добавляйте jti и ревокацию.
  return jwt.sign(payload, JWT_REFRESH_SECRET, { expiresIn: "7d" });
}

// Middleware для защиты маршрутов
function authenticate(req, res, next) {
  const auth = req.headers.authorization || "";
  const [, token] = auth.split(" "); // "Bearer <token>"

  if (!token) return res.status(401).json({ error: "No token provided" });

  jwt.verify(token, JWT_SECRET, (err, decoded) => {
    if (err) return res.status(401).json({ error: "Invalid or expired token" });
    req.user = decoded; // { id, username, role, iat, exp }
    next();
  });
}

/** Логин: проверяем пользователя, выдаём пары токенов */
app.post("/api/login", async (req, res) => {
  const { username, password } = req.body || {};
  const user = users.find((u) => u.username === username);
  if (!user) return res.status(401).json({ error: "Invalid credentials" });

  const ok = await bcrypt.compare(password, user.passwordHash);
  if (!ok) return res.status(401).json({ error: "Invalid credentials" });

  const payload = { id: user.id, username: user.username, role: user.role };
  const accessToken = signAccessToken(payload);
  const refreshToken = signRefreshToken({ id: user.id });

  refreshStore.add(refreshToken);

  res.json({ accessToken, refreshToken });
});

/** Обновление access-токена по refresh-токену */
app.post("/api/refresh", (req, res) => {
  const { refreshToken } = req.body || {};
  if (!refreshToken) return res.status(400).json({ error: "No refresh token" });
  if (!refreshStore.has(refreshToken)) {
    return res.status(401).json({ error: "Refresh token revoked or unknown" });
  }

  jwt.verify(refreshToken, JWT_REFRESH_SECRET, (err, decoded) => {
    if (err) return res.status(401).json({ error: "Invalid or expired refresh token" });

    // Получаем пользователя (минимум id в payload refresh)
    const user = users.find((u) => u.id === decoded.id);
    if (!user) return res.status(401).json({ error: "User no longer exists" });

    const payload = { id: user.id, username: user.username, role: user.role };
    const newAccessToken = signAccessToken(payload);

    res.json({ accessToken: newAccessToken });
  });
});

/** Логаут: ревокация refresh-токена */
app.post("/api/logout", (req, res) => {
  const { refreshToken } = req.body || {};
  if (refreshToken) refreshStore.delete(refreshToken);
  res.json({ success: true });
});

/** Пример защищённого маршрута */
app.get("/api/profile", authenticate, (req, res) => {
  // req.user пришёл из access-токена
  res.json({
    message: "Protected resource",
    user: req.user,
  });
});

/** Пример защищённого маршрута с проверкой роли */
function authorize(roles = []) {
  return (req, res, next) => {
    if (!roles.length || roles.includes(req.user.role)) return next();
    return res.status(403).json({ error: "Forbidden" });
  };
}
app.get("/api/admin", authenticate, authorize(["admin"]), (req, res) => {
  res.json({ message: "Hello, admin!" });
});

app.listen(PORT, () => {
  console.log(`Auth server running on http://localhost:${PORT}`);
});


/////////////////////////////////////////
<script>
  let accessToken = null;
  let refreshToken = null;

  async function login() {
    const res = await fetch("http://localhost:3000/api/login", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ username: "user1", password: "xxx" })
    });
    const data = await res.json();
    if (!res.ok) throw new Error(data.error || "Login failed");
    accessToken = data.accessToken;
    refreshToken = data.refreshToken;
    console.log("Logged in:", { accessToken, refreshToken });
  }

  async function callProtected() {
    let res = await fetch("http://localhost:3000/api/profile", {
      headers: { Authorization: `Bearer ${accessToken}` }
    });

    // Если токен протух — запросим новый по refresh и повторим
    if (res.status === 401 && refreshToken) {
      const r = await fetch("http://localhost:3000/api/refresh", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ refreshToken })
      });
      const d = await r.json();
      if (r.ok && d.accessToken) {
        accessToken = d.accessToken;
        res = await fetch("http://localhost:3000/api/profile", {
          headers: { Authorization: `Bearer ${accessToken}` }
        });
      }
    }

    const data = await res.json();
    console.log("Protected response:", data);
  }

  async function logout() {
    await fetch("http://localhost:3000/api/logout", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ refreshToken })
    });
    accessToken = null;
    refreshToken = null;
    console.log("Logged out");
  }

  // Пример последовательности:
  // await login(); await callProtected(); await logout();
</script>


при работе (упрощенном с куки)
Установи зависимости:
npm i express cors cookie-parser

Код сервера (server.js):

const express = require("express");
const cors = require("cors");
const cookieParser = require("cookie-parser");
const app = express();
const port = 3000;

// Настройки
app.use(cors({
  origin: "http://localhost:8080", // твой фронтенд
  credentials: true                // разрешаем куки
}));
app.use(express.json());
app.use(cookieParser());

// Логин — выставляем cookie
app.post("/login", (req, res) => {
  const { username, password } = req.body;
  if (username === "user1" && password === "xxx") {
    // Устанавливаем cookie
    res.cookie("sessionId", "abc123", {
      httpOnly: true,   // нельзя прочитать из JS
      secure: false,    // true в продакшене (только HTTPS)
      sameSite: "lax"   // поведение в кросс-доменных запросах
    });
    return res.json({ success: true, message: "Логин успешен" });
  }
  res.status(401).json({ success: false, message: "Неверные данные" });
});

// Защищённый ресурс — читаем cookie
app.get("/profile", (req, res) => {
  const sessionId = req.cookies.sessionId;
  if (sessionId === "abc123") {
    return res.json({ success: true, user: "user1", sessionId });
  }
  res.status(403).json({ success: false, message: "Нет доступа" });
});

app.listen(port, () => {
  console.log(`Server running on http://localhost:${port}`);
});

Клиент (JS, например в браузере)
Важно: чтобы fetch отправлял куки, нужно указывать credentials: "include".
POST (логин)
async function login() {
  const res = await fetch("http://localhost:3000/login", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    credentials: "include", // ⚠️ обязательно для cookies
    body: JSON.stringify({ username: "user1", password: "xxx" })
  });
  const data = await res.json();
  console.log("Ответ на логин:", data);
}

GET (доступ к защищённому ресурсу)
async function getProfile() {
  const res = await fetch("http://localhost:3000/profile", {
    method: "GET",
    credentials: "include" // куки прикрепятся сами
  });
  const data = await res.json();
  console.log("Ответ профиля:", data);
}

Как это работает
Клиент делает login(). Сервер отправляет ответ с заголовком:
Set-Cookie: sessionId=abc123; HttpOnly; Secure; SameSite=Lax
Браузер сохраняет cookie.
Клиент делает getProfile().
Браузер автоматически добавит заголовок:
Cookie: sessionId=abc123
Сервер прочитает его через req.cookies.sessionId.


...............
Как подключить .env в Node.js
Установи библиотеку dotenv:
npm install dotenv

В начале твоего кода (server.js):
require("dotenv").config();
const PORT = process.env.PORT || 3000;
const JWT_SECRET = process.env.JWT_SECRET;
const JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET;
console.log("Server will run on port:", PORT);

Теперь process.env будет содержать данные из .env.
